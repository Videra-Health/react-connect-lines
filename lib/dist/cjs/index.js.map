{"mappings":"0QAGO,MAAMA,GAAyB,EAAAC,EAAAC,eAA2C,CAC/EC,SAAU,GACVC,SAAU,IAAM,OCFX,SAASC,IAGd,KAFe,EAAAJ,EAAAK,YAAWN,GAGxB,MAAM,IAAIO,MAAM,yBAGlB,OAAO,EAAAN,EAAAK,YAAWN,GCRb,SAASQ,EACdC,EACAC,GAEA,MAAMC,KAACA,EAAIC,GAAEA,EAAEC,QAAEA,EAAOC,YAAEA,GAAeJ,EAEnCK,EAASN,GAAON,UAAUa,MAAMC,GAAMA,EAAEL,KAAOA,IAE/CM,EAAwD,C,GAC5DN,E,QACAC,EACAC,YAJqBA,GAAe,IAOtC,GAAa,QAATH,GAAkBE,EAAS,CAC7B,IAAKE,EACH,MAAO,IACFN,EACHN,SAAU,IAAIM,EAAMN,SAAUe,IAIlC,GAAIH,EAAQ,CACV,MAAMI,EAAO,IAAIV,EAAMN,UAAUiB,KAAKC,GAChCA,EAAGT,KAAOA,EACLM,EAGFG,IAGT,MAAO,IAAIZ,EAAON,SAAUgB,GAG9B,OAAOV,EAGT,MAAa,WAATE,EACK,IACFF,EACHN,SAAUM,EAAMN,SACbiB,KAAKE,IACG,IACFA,EACHR,YAAaQ,EAAER,aAAaS,QAAQC,GAAMA,EAAEZ,KAAOA,QAGtDW,QAAQF,GAAOA,EAAGT,KAAOA,KAIzBH,EC7CF,SAASgB,EAAwBC,GACtC,MAAMC,SAACA,GAAYD,GACZjB,EAAOL,IAAY,EAAAH,EAAA2B,YAAWpB,EAAwB,CAC3DL,SAAU,GACVC,SAAU,IAAM,OAGZyB,GAAS,EAAA5B,EAAA6B,UACb,KAAO,CACL3B,SAAUM,EAAMN,SAChBC,SAAUA,KAEZ,CAACK,IAGH,OACE,EAAAsB,EAAAC,KAAChC,EAAuBiC,SAAQ,CAACC,MAAOL,E,SAASF,IChB9C,SAASQ,EAAQT,GACtB,MAAMC,SAACA,EAAQf,GAAEA,EAAEE,YAAEA,GAAeY,GAC9BtB,SAACA,GAAYC,IACb+B,GAAU,EAAAnC,EAAAoC,UAEVC,GAAY,EAAArC,EAAAsC,cAAY,KAC5BnC,EAAS,CACPO,KAAM,M,GACNC,E,YACAE,EACAD,QAASuB,EAAQI,YAElB,CAAC1B,EAAaV,EAAUQ,IAErB6B,GAAQ,EAAAxC,EAAA6B,UAAQ,KACpB,MAAOJ,MAAOgB,GAAcf,EAE5B,OAAO,EAAA1B,EAAA0C,cAAahB,EAAU,IACzBe,EACHE,IAAM1B,IACJkB,EAAQI,QAAUtB,EAEM,mBAAbS,GAAyBe,EAAWE,IAAI1B,QAGtD,CAACS,IAeJ,OAbA,EAAA1B,EAAA4C,YAAU,KACRP,MACC,CAACZ,EAAOY,EAAWF,KAEtB,EAAAnC,EAAA4C,YAAU,IACD,KACLzC,EAAS,CACPO,KAAM,S,GACNC,MAGH,CAACR,EAAUQ,IAEP6B,ECzCF,MAAMK,EAAWpB,IACtB,MAAMqB,MAACA,EAAKC,KAAEA,GAAQtB,EAWtB,MATa,KAAKqB,EACf3B,KAAI,CAAC6B,EAAGC,IACO,IAAVA,GAAwB,SAATF,EAAwB,GAAGC,EAAE3B,KAAK2B,EAAEzB,IACzC,IAAV0B,GAAwB,WAATF,EAA0B,KAAKC,EAAE3B,KAAK2B,EAAEzB,IAEpD,GAAGyB,EAAE3B,KAAK2B,EAAEzB,MAEpB2B,KAAK,QCfH,SAASC,EAAW/B,GACzB,OAAKA,EAAGR,QAIDQ,EAAGR,QAHDwC,SAASC,cAAc,IAAIjC,EAAGT,MCDzC,MAAM2C,EAAkB,GAMjB,SAASC,EAAsB9B,GACpC,MAAMvB,SAACA,GAAYuB,EAoCnB,OAhCgBvB,EACboB,QAAQkC,IAAOA,GAAG3C,aAAeyC,GAAaG,OAAS,IACvDtC,KAAKC,IACJ,MAAMP,YAACA,GAAeO,EAIhBsC,EAAaxD,EAChBoB,QAAQqC,GAAM9C,GAAaM,KAAKyC,GAAMA,EAAEjD,KAAIkD,SAASF,EAAEhD,MACvDQ,KAAKE,IACG,CACLyC,KAAMX,EAAW9B,IAAI0C,wBACrBC,MAAOnD,GAAaoD,MAAML,GAAMA,EAAEjD,KAAOU,EAAEV,MAAKqD,OAAS,UACzDjB,KAAMlC,GAAaoD,MAAML,GAAMA,EAAEjD,KAAOU,EAAEV,MAAKoC,MAAQ,SACvDmB,OAAQrD,GAAaoD,MAAML,GAAMA,EAAEjD,KAAOU,EAAEV,MAAKuD,QAAU,QAC3DvD,GAAIU,EAAEV,OAKZ,GAA0B,IAAtB+C,EAAWD,OAEf,MAAO,CACLU,KAAM,IACD/C,EACH0C,KAAMX,EAAW/B,IAAK2C,yBAExBK,GAAIV,MAGPpC,OAAO+C,SCdL,SAASC,EAAY7C,GAC1B,MAAM0C,KAACA,EAAIC,GAAEA,GAAM3C,EACb8C,EAAWJ,GAAML,KACjBU,EAASJ,GAAIN,KAEnB,IAAKS,IAAaC,EAAQ,OAE1B,MAAMC,EAxBR,SAAqBhD,GACnB,MAAM0C,KAACA,EAAIC,GAAEA,GAAM3C,EAEbiD,EACJP,EAAKQ,KANU,GAMUP,EAAGQ,OAAST,EAAKS,MAAQR,EAAGS,MAAQT,EAAGQ,MANjD,GAQXE,EAAcX,EAAKY,OAASX,EAAGY,KAAON,EACtCO,EAAcd,EAAKa,IAAMZ,EAAGW,QAAUL,EACtCQ,EAAcf,EAAKQ,KAAOP,EAAGQ,MAC7BO,EAAchB,EAAKS,MAAQR,EAAGO,KAEpC,OAAIG,EAAoB,gBACpBG,EAAoB,gBACpBC,EAAoB,gBACpBC,EAAoB,qBAAxB,EAUiBC,CAAY,CAACjB,KAAMI,EAAUH,GAAII,IAElD,OAAQC,GACN,IAAK,gBACH,MAAO,CACL,CACEpD,EAAGkD,GAAUI,KAAOJ,EAASM,MAAQ,EACrCtD,EAAGgD,GAAUQ,QAEf,CACE1D,EAAGkD,GAAUI,KAAOJ,EAASM,MAAQ,EACrCtD,EAAGgD,EAASQ,QAAUR,EAASQ,OAASP,EAAOQ,KAAO,GAExD,CACE3D,EAAGmD,GAAQG,KAAOH,EAAOK,MAAQ,EACjCtD,EAAGgD,EAASQ,QAAUR,EAASQ,OAASP,EAAOQ,KAAO,GAExD,CACE3D,EAAGmD,GAAQG,KAAOH,EAAOK,MAAQ,EACjCtD,EAAGiD,EAAOQ,IA9CA,IAmDhB,IAAK,gBACH,MAAO,CACL,CACE3D,EAAGkD,GAAUI,KAAOJ,EAASM,MAAQ,EACrCtD,EAAGgD,GAAUS,KAEf,CACE3D,EAAGkD,GAAUI,KAAOJ,EAASM,MAAQ,EACrCtD,EAAGgD,EAASS,KAAOT,EAASS,IAAMR,EAAOO,QAAU,GAErD,CACE1D,EAAGmD,GAAQG,KAAOH,EAAOK,MAAQ,EACjCtD,EAAGgD,EAASS,KAAOT,EAASS,IAAMR,EAAOO,QAAU,GAErD,CACE1D,EAAGmD,GAAQG,KAAOH,EAAOK,MAAQ,EACjCtD,EAAGiD,EAAOO,OAnEA,IAwEhB,IAAK,gBACH,MAAO,CACL,CACE1D,EAAGkD,GAAUI,KACbpD,EAAGgD,GAAUQ,OAASR,EAASc,OAAS,GAE1C,CACEhE,GAAImD,EAAOI,MAAQL,EAASI,MAAQ,EACpCpD,EAAGgD,GAAUQ,OAASR,EAASc,OAAS,GAE1C,CACEhE,GAAImD,EAAOI,MAAQL,EAASI,MAAQ,EACpCpD,EAAGiD,EAAOQ,IAAMR,EAAOa,OAAS,GAElC,CACEhE,EAAGmD,EAAOI,MAvFA,EAwFVrD,EAAGiD,EAAOQ,IAAMR,EAAOa,OAAS,IAKtC,IAAK,gBACH,MAAO,CACL,CACEhE,EAAGkD,GAAUK,MACbrD,EAAGgD,GAAUQ,OAASR,EAASc,OAAS,GAE1C,CACEhE,GAAImD,EAAOG,KAAOJ,EAASK,OAAS,EACpCrD,EAAGgD,GAAUQ,OAASR,EAASc,OAAS,GAE1C,CACEhE,GAAImD,EAAOG,KAAOJ,EAASK,OAAS,EACpCrD,EAAGiD,EAAOQ,IAAMR,EAAOa,OAAS,GAElC,CACEhE,EAAGmD,EAAOG,KA5GA,EA6GVpD,EAAGiD,EAAOQ,IAAMR,EAAOa,OAAS,IAKtC,QACE,MAAO,ICzHb,MAAMC,EAAiC,CACrCb,SAAU,QACVO,IAAK,IACLL,KAAM,IACNC,MAAO,IACPG,OAAQ,IACRQ,cAAe,OACfV,MAAO,OACPQ,OAAQ,QAIJG,EAAkB,GAoBjB,SAASC,EAAahE,GAC3B,MAAOiE,EAAYC,IAAiB,EAAA3F,EAAA4F,UAAqBJ,IAClDK,EAAeC,IAAoB,EAAA9F,EAAA4F,WAAkB,IACtD1F,SAACA,GAAYuB,EACbsE,GAAM,EAAA/F,EAAAoC,UAMN4D,GAAS,EAAAhG,EAAA6B,UACb,IACE,IACK,IAAIoE,IAAI,IACN/F,EAASiB,KAAKqC,GAAMA,EAAE3C,aAAaM,KAAKwC,GAAMA,GAAGK,UAAQkC,OAnChD,aAsCd5E,OAAO+C,UACX,CAACnE,IAGGiG,GAAkB,EAAAnG,EAAAsC,cAAY,KAC9ByD,EAAIxD,SACN6D,OAAOC,qBAAqBN,EAAIxD,SAGlCwD,EAAIxD,QAAU6D,OAAOE,uBAAsB,KAczC,MAyCMC,EAzCqBhD,EAAsB,C,SAACrD,IAG/CiB,KAAKqF,IACJ,MAAMrC,KAACA,EAAMC,GAAIqC,GAAWD,GAAQ,GAE9BE,EAAcD,GAAStF,KAAKiD,IAKhC,MAAMuC,EAAWrC,EAAY,CAACH,KAAMA,EAAMC,GAAIA,IAE9C,IAAKuC,EAAU,OAKf,MAAMC,EAAO/D,EAAQ,CAACC,MAAO6D,EAAU5D,KAAMqB,GAAIrB,OAKjD,MAAK,KAAK8D,KAAKD,GAKR,CACLE,OAAQ3C,GAAMxD,GACdoG,KAAM3C,GAAIzD,GACVqG,EAAGJ,KACAxC,QATL,KAaF,OAAOsC,KAERpF,OAAO+C,SACP6B,OAEiB5E,QAAQ0B,GAAMqB,QAAQrB,KAE1C2C,EAAcY,QAEf,CAACrG,IAKE+G,GAAyB,EAAAjH,EAAAsC,cAAY,KACzCwD,GAAiB,KAChB,IAEGoB,GAAwB,EAAAlH,EAAAsC,cAAY,KACxCwD,GAAiB,KAChB,IAEGqB,GAAoB,EAAAnH,EAAAsC,cAAY,KAChCuD,GAAeM,MAClB,CAACA,EAAiBN,KAErB,EAAA7F,EAAA4C,YAAU,KACRuD,MACC,CAACA,KAEJ,EAAAnG,EAAA4C,YAAU,KACRwD,OAAOgB,iBAAiB,SAAUjB,EAAiB,CAACkB,SAAS,IAC7DjB,OAAOgB,iBAAiB,SAAUjB,EAAiB,CAACkB,SAAS,IAEtD,KACLjB,OAAOkB,oBAAoB,SAAUnB,GACrCC,OAAOkB,oBAAoB,SAAUnB,MAEtC,CAACA,IAEJ,MAAMoB,GAAK,EAAAvH,EAAA6B,UAAQ,IAAM,IAAI2F,eAAerB,IAAkB,CAACA,IA4C/D,OA1CA,EAAAnG,EAAA4C,YAAU,KACR1C,EAASuH,SAASrG,IAChB,MAAMR,EAAUuC,EAAW/B,GAE3BR,GAASwG,iBAAiB,YAAaH,EAAwB,CAACI,SAAS,IACzEzG,GAASwG,iBAAiB,UAAWF,EAAuB,CAACG,SAAS,IACtEzG,GAASwG,iBAAiB,YAAaD,EAAmB,CAACE,SAAS,IACpEzG,GAASwG,iBAAiB,aAAcH,EAAwB,CAACI,SAAS,IAC1EzG,GAASwG,iBAAiB,WAAYF,EAAuB,CAACG,SAAS,IACvEzG,GAASwG,iBAAiB,YAAaD,EAAmB,CAACE,SAAS,IAEhEzG,GACF2G,EAAGG,QAAQ9G,MAIR,KACLV,EAASuH,SAASrG,IAChB,MAAMR,EAAUuC,EAAW/B,GAE3BR,GAAS0G,oBAAoB,YAAaL,GAC1CrG,GAAS0G,oBAAoB,UAAWJ,GACxCtG,GAAS0G,oBAAoB,YAAaH,GAC1CvG,GAAS0G,oBAAoB,aAAcL,GAC3CrG,GAAS0G,oBAAoB,WAAYJ,GACzCtG,GAAS0G,oBAAoB,YAAaH,GAEtCvG,IACF2G,EAAGI,aACHJ,EAAGK,UAAUhH,UAIlB,CACDV,EACAiG,EACAc,EACAC,EACAC,EACAI,KAGK,EAAAvH,EAAA6B,UACL,KACE,EAAAC,EAAA+F,MAAC,MAAG,CAACC,MAAOxC,E,UACTU,GAAQ7E,KAAKwC,IACZ,EAAA7B,EAAAC,KAAC,OAAI,C,UACH,EAAAD,EAAAC,KAAC,SAAM,CACLpB,GAAI,YAAYgD,IAChBoE,aAAa,IACbC,YAAY,cACZC,YAAY,IACZC,OAAO,OACPC,KAAK,IACLC,KAAK,IACLC,QAAQ,Y,UAER,EAAAvG,EAAAC,KAAC,OAAI,CAACiF,EAAE,wBAAwBsB,KAAM3E,OAX/BA,KAiBZ+B,GAAYvE,KAAK6B,IAEd,EAAAlB,EAAAC,KAAC,OAAI,CACHpB,GAAI,GAAGqC,GAAG8D,UAAU9D,GAAG+D,OACvBC,EAAGhE,GAAGgE,EACNsB,KAAK,OAELC,UAAW,iBAAiBvF,GAAGgB,SAC/BE,OAAQlB,GAAGgB,MACXwE,YAAY,IACZC,gBAA+B,WAAdzF,GAAGkB,OAAsB,EAAI,EAC9CwE,eAAe,SALV1F,GAAGgE,SAWlB,CAAChB,EAAQN,IClOb,SAASiD,IACP,MAAMzI,SAACA,GAAYE,IAEnB,OAAO,EAAA0B,EAAAC,KAAC0D,EAAY,CAACvF,SAAUA,IAG1B,SAAS0I,EAAgBnH,GAC9B,MAAMC,SAACA,GAAYD,EAEnB,OACE,EAAAK,EAAA+F,MAACrG,EAAuB,C,UACrBE,GACD,EAAAI,EAAAC,KAAC4G,EAAoB","sources":["elements/context.ts","elements/hooks.ts","elements/reducer.ts","elements/provider.tsx","Connect.tsx","lines/utils/pathify.ts","lines/utils/getElement.ts","lines/utils/getGroupedConnections.ts","lines/utils/getPathData.ts","lines/ConnectLines.tsx","ConnectProvider.tsx"],"sourcesContent":["import {createContext} from 'react'\nimport {ConnectElementsContextValue} from '../types'\n\nexport const ConnectElementsContext = createContext<ConnectElementsContextValue>({\n  elements: [],\n  dispatch: () => null,\n})\n","import {useContext} from 'react'\nimport {ConnectElementsContext} from './context'\n\nexport function useConnectElements() {\n  const ctxVal = useContext(ConnectElementsContext)\n\n  if (!ctxVal) {\n    throw new Error('Missing context value')\n  }\n\n  return useContext(ConnectElementsContext)\n}\n","import {ConnectElement, ConnectElementsContextValue, ConnectElementsReducerPayload} from '../types'\n\nexport function connectElementsReducer(\n  state: ConnectElementsContextValue,\n  payload: ConnectElementsReducerPayload\n): ConnectElementsContextValue {\n  const {type, id, element, connectWith} = payload\n\n  const exists = state?.elements?.some((l) => l.id === id)\n  const connectWithArr = connectWith || []\n  const node: ConnectElement & {element?: HTMLElement | null} = {\n    id,\n    element,\n    connectWith: connectWithArr,\n  }\n\n  if (type === 'add' && element) {\n    if (!exists) {\n      return {\n        ...state,\n        elements: [...state.elements, node],\n      }\n    }\n\n    if (exists) {\n      const next = [...state.elements].map((el) => {\n        if (el.id === id) {\n          return node\n        }\n\n        return el\n      })\n\n      return {...state, elements: next}\n    }\n\n    return state\n  }\n\n  if (type === 'remove') {\n    return {\n      ...state,\n      elements: state.elements\n        .map((x) => {\n          return {\n            ...x,\n            connectWith: x.connectWith?.filter((y) => y.id !== id),\n          }\n        })\n        .filter((el) => el.id !== id),\n    }\n  }\n\n  return state\n}\n","import {useMemo, useReducer} from 'react'\nimport {ConnectElementsContext} from './context'\nimport {connectElementsReducer} from './reducer'\n\ninterface ConnectElementsProviderProps {\n  children: React.ReactNode\n}\n\nexport function ConnectElementsProvider(props: ConnectElementsProviderProps) {\n  const {children} = props\n  const [state, dispatch] = useReducer(connectElementsReducer, {\n    elements: [],\n    dispatch: () => null,\n  })\n\n  const ctxVal = useMemo(\n    () => ({\n      elements: state.elements,\n      dispatch: dispatch,\n    }),\n    [state]\n  )\n\n  return (\n    <ConnectElementsContext.Provider value={ctxVal}>{children}</ConnectElementsContext.Provider>\n  )\n}\n","import React, {cloneElement, useCallback, useEffect, useMemo, useRef} from 'react'\nimport {useConnectElements} from './elements'\nimport {ConnectElement} from './types'\n\ninterface ConnectProps extends Omit<ConnectElement, 'element'> {\n  children: React.ReactElement\n}\n\nexport function Connect(props: ConnectProps) {\n  const {children, id, connectWith} = props\n  const {dispatch} = useConnectElements()\n  const nodeRef = useRef<HTMLElement>()\n\n  const handleAdd = useCallback(() => {\n    dispatch({\n      type: 'add',\n      id,\n      connectWith,\n      element: nodeRef.current,\n    })\n  }, [connectWith, dispatch, id])\n\n  const clone = useMemo(() => {\n    const {props: childProps} = children\n\n    return cloneElement(children, {\n      ...childProps,\n      ref: (node: HTMLElement) => {\n        nodeRef.current = node\n\n        if (typeof children === 'function') childProps.ref(node)\n      },\n    })\n  }, [children])\n\n  useEffect(() => {\n    handleAdd()\n  }, [props, handleAdd, nodeRef])\n\n  useEffect(() => {\n    return () => {\n      dispatch({\n        type: 'remove',\n        id,\n      })\n    }\n  }, [dispatch, id])\n\n  return clone\n}\n","import {Edge} from '../../types'\n\ninterface PathifyProps {\n  paths: {x: string | number; y: string | number}[]\n  edge?: Edge\n}\n\nexport const pathify = (props: PathifyProps) => {\n  const {paths, edge} = props\n\n  const path = `M ${paths\n    .map((p, index) => {\n      if (index === 1 && edge === 'step') return `${p.x} ${p.y}`\n      if (index === 1 && edge === 'bezier') return `C ${p.x} ${p.y}`\n\n      return `${p.x} ${p.y}`\n    })\n    .join(' ')}`\n\n  return path\n}\n","import {ConnectElement} from '../../types'\n\nexport function getElement(el: ConnectElement & {element?: HTMLElement}) {\n  if (!el.element) {\n    return document.querySelector(`#${el.id}`)\n  }\n\n  return el.element\n}\n","import {ConnectElement} from '../../types'\nimport {getElement} from './getElement'\n\nconst EMPTY_ARRAY: [] = []\n\ninterface GetGroupedConnectionsProps {\n  elements: ConnectElement[]\n}\n\nexport function getGroupedConnections(props: GetGroupedConnectionsProps) {\n  const {elements} = props\n\n  // const connections = elements?.map((e) => e.connectWith?.map((x) => x?.id)).flat()\n\n  const grouped = elements\n    .filter((e) => (e?.connectWith || EMPTY_ARRAY).length > 0)\n    .map((el) => {\n      const {connectWith} = el\n\n      // const connectionsLen = connections.filter((y) => y === el.id)?.length || 0\n\n      const connectEls = elements\n        .filter((c) => connectWith?.map((a) => a.id).includes(c.id))\n        .map((x) => {\n          return {\n            rect: getElement(x)?.getBoundingClientRect(),\n            color: connectWith?.find((a) => a.id === x.id)?.color || '#000000',\n            edge: connectWith?.find((a) => a.id === x.id)?.edge || 'bezier',\n            stroke: connectWith?.find((a) => a.id === x.id)?.stroke || 'solid',\n            id: x.id\n            // connectionsLen: connectionsLen,\n          }\n        })\n\n      if (connectEls.length === 0) return\n\n      return {\n        from: {\n          ...el,\n          rect: getElement(el)?.getBoundingClientRect(),\n        },\n        to: connectEls,\n      }\n    })\n    .filter(Boolean)\n\n  return grouped\n}\n","interface GetPathDataProps {\n  from?: {\n    id: string,\n    rect: DOMRect | undefined\n  }\n  to?: {\n    rect: DOMRect | undefined\n  }\n}\n\nconst LINE_OFFSET = 9\nconst POS_OFFSET = 40\n\nfunction getPosition(props: {from: DOMRect; to: DOMRect}) {\n  const {from, to} = props\n\n  const allowYConnect =\n    from.left - POS_OFFSET < to.right && from.right + to.width > to.right - POS_OFFSET\n\n  const bottomToTop = from.bottom < to.top && allowYConnect\n  const topToBottom = from.top > to.bottom && allowYConnect\n  const rightToLeft = from.left > to.right\n  const leftToRight = from.right < to.left\n\n  if (bottomToTop) return 'bottom-to-top'\n  if (topToBottom) return 'top-to-bottom'\n  if (rightToLeft) return 'right-to-left'\n  if (leftToRight) return 'left-to-right'\n}\n\nexport function getPathData(props: GetPathDataProps) {\n  const {from, to} = props\n  const fromRect = from?.rect\n  const toRect = to?.rect\n\n  if (!fromRect || !toRect) return\n\n  const position = getPosition({from: fromRect, to: toRect})\n\n  switch (position) {\n    case 'bottom-to-top': {\n      return [\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect?.bottom,\n        },\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect.bottom - (fromRect.bottom - toRect.top) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: fromRect.bottom - (fromRect.bottom - toRect.top) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: toRect.top - LINE_OFFSET,\n        },\n      ]\n    }\n\n    case 'top-to-bottom': {\n      return [\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect?.top,\n        },\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect.top - (fromRect.top - toRect.bottom) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: fromRect.top - (fromRect.top - toRect.bottom) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: toRect.bottom + LINE_OFFSET,\n        },\n      ]\n    }\n\n    case 'right-to-left': {\n      return [\n        {\n          x: fromRect?.left,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.right + fromRect.left) / 2,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.right + fromRect.left) / 2,\n          y: toRect.top + toRect.height / 2,\n        },\n        {\n          x: toRect.right + LINE_OFFSET,\n          y: toRect.top + toRect.height / 2,\n        },\n      ]\n    }\n\n    case 'left-to-right': {\n      return [\n        {\n          x: fromRect?.right,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.left + fromRect.right) / 2,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.left + fromRect.right) / 2,\n          y: toRect.top + toRect.height / 2,\n        },\n        {\n          x: toRect.left - LINE_OFFSET,\n          y: toRect.top + toRect.height / 2,\n        },\n      ]\n    }\n\n    default:\n      return []\n  }\n}\n","import {useCallback, useEffect, useMemo, useRef, useState} from 'react'\nimport {ConnectElement, Edge, Stroke} from '../types'\nimport {getElement, getGroupedConnections, getPathData, pathify} from './utils'\n\nconst SVG_STYLE: React.CSSProperties = {\n  position: 'fixed',\n  top: '0',\n  left: '0',\n  right: '0',\n  bottom: '0',\n  pointerEvents: 'none',\n  width: '100%',\n  height: '100%',\n}\n\nconst DEFAULT_COLOR = '#000000'\nconst EMPTY_ARRAY: [] = []\n\ntype PointsData = (\n  | {\n      rect: DOMRect | undefined\n      color: string | undefined\n      edge: Edge\n      stroke: Stroke\n      d: string,\n      id: string,\n      toId: string | undefined,\n      fromId: string | undefined\n    }\n  | undefined\n)[]\n\ninterface ConnectLinesProps {\n  elements: ConnectElement[]\n}\n\nexport function ConnectLines(props: ConnectLinesProps) {\n  const [pointsData, setPointsData] = useState<PointsData>(EMPTY_ARRAY)\n  const [isInteracting, setIsInteracting] = useState<boolean>(false)\n  const {elements} = props\n  const raf = useRef<number>()\n\n  /**\n   * Create array of all colors configured.\n   * These colors is used to render the svg markers (e.g arrows).\n   */\n  const colors = useMemo(\n    () =>\n      [\n        ...new Set([\n          ...elements.map((e) => e.connectWith?.map((c) => c?.color)).flat(),\n          DEFAULT_COLOR,\n        ]),\n      ].filter(Boolean),\n    [elements]\n  )\n\n  const handleCalcLines = useCallback(() => {\n    if (raf.current) {\n      window.cancelAnimationFrame(raf.current)\n    }\n\n    raf.current = window.requestAnimationFrame(() => {\n      /**\n       * The `getGroupedConnections` function returns:\n       *\n       *  {\n       *    from: DOMRect,\n       *    to: {\n       *       rect: DOMRect,\n       *       color: string,\n       *       edge: string,\n       *       stroke: string\n       *    }[]\n       *  }\n       */\n      const groupedConnections = getGroupedConnections({elements})\n\n      const points = groupedConnections\n        .map((data) => {\n          const {from, to: toArray} = data || {}\n\n          const pathDataArr = toArray?.map((to) => {\n            /**\n             * The `getPathData` function returns an array of objects with\n             * x and y coordinates for the line.\n             */\n            const pathData = getPathData({from: from, to: to})\n\n            if (!pathData) return\n\n            /**\n             * The `pathify` functions returns a svg-readable string of the coordinates\n             */\n            const path = pathify({paths: pathData, edge: to?.edge})\n\n            /**\n             * Dummy validation of the path\n             */\n            if (!/\\d/.test(path)) return\n\n            /**\n             * Return the path (d) together with other relevant data such as color, stroke, edge.\n             */\n            return {\n              fromId: from?.id,\n              toId: to?.id,\n              d: path,\n              ...to,\n            }\n          })\n\n          return pathDataArr\n        })\n        .filter(Boolean)\n        .flat()\n\n      const data = points.filter((p) => Boolean(p))\n\n      setPointsData(data)\n    })\n  }, [elements])\n\n  /**\n   * Handle drag and drop gestures and update the paths\n   */\n  const handleStartInteracting = useCallback(() => {\n    setIsInteracting(true)\n  }, [])\n\n  const handleStopInteracting = useCallback(() => {\n    setIsInteracting(false)\n  }, [])\n\n  const handleUpdateLines = useCallback(() => {\n    if (isInteracting) handleCalcLines()\n  }, [handleCalcLines, isInteracting])\n\n  useEffect(() => {\n    handleCalcLines()\n  }, [handleCalcLines])\n\n  useEffect(() => {\n    window.addEventListener('resize', handleCalcLines, {passive: true})\n    window.addEventListener('scroll', handleCalcLines, {passive: true})\n\n    return () => {\n      window.removeEventListener('resize', handleCalcLines)\n      window.removeEventListener('scroll', handleCalcLines)\n    }\n  }, [handleCalcLines])\n\n  const ro = useMemo(() => new ResizeObserver(handleCalcLines), [handleCalcLines])\n\n  useEffect(() => {\n    elements.forEach((el) => {\n      const element = getElement(el)\n\n      element?.addEventListener('mousedown', handleStartInteracting, {passive: true})\n      element?.addEventListener('mouseup', handleStopInteracting, {passive: true})\n      element?.addEventListener('mousemove', handleUpdateLines, {passive: true})\n      element?.addEventListener('touchstart', handleStartInteracting, {passive: true})\n      element?.addEventListener('touchend', handleStopInteracting, {passive: true})\n      element?.addEventListener('touchmove', handleUpdateLines, {passive: true})\n\n      if (element) {\n        ro.observe(element)\n      }\n    })\n\n    return () => {\n      elements.forEach((el) => {\n        const element = getElement(el)\n\n        element?.removeEventListener('mousedown', handleStartInteracting)\n        element?.removeEventListener('mouseup', handleStopInteracting)\n        element?.removeEventListener('mousemove', handleUpdateLines)\n        element?.removeEventListener('touchstart', handleStartInteracting)\n        element?.removeEventListener('touchend', handleStopInteracting)\n        element?.removeEventListener('touchmove', handleUpdateLines)\n\n        if (element) {\n          ro.disconnect()\n          ro.unobserve(element)\n        }\n      })\n    }\n  }, [\n    elements,\n    handleCalcLines,\n    handleStartInteracting,\n    handleStopInteracting,\n    handleUpdateLines,\n    ro,\n  ])\n\n  return useMemo(\n    () => (\n      <svg style={SVG_STYLE}>\n        {colors?.map((c) => (\n          <defs key={c}>\n            <marker\n              id={`triangle-${c}`}\n              markerHeight=\"5\"\n              markerUnits=\"strokeWidth\"\n              markerWidth=\"5\"\n              orient=\"auto\"\n              refX=\"1\"\n              refY=\"5\"\n              viewBox=\"0 0 10 10\"\n            >\n              <path d=\"M 0 0 L 10 5 L 0 10 z\" fill={c} />\n              {/* <circle cx=\"5\" cy=\"5\" r=\"5\" fill={c} /> */}\n            </marker>\n          </defs>\n        ))}\n\n        {pointsData?.map((p) => {\n          return (\n            <path\n              id={`${p?.fromId}-${p?.toId}`}\n              d={p?.d}\n              fill=\"none\"\n              key={p?.d}\n              markerEnd={`url(#triangle-${p?.color})`}\n              stroke={p?.color}\n              strokeWidth=\"2\"\n              strokeDasharray={p?.stroke === 'dashed' ? 4 : 0}\n              strokeLinejoin=\"round\"\n            />\n          )\n        })}\n      </svg>\n    ),\n    [colors, pointsData]\n  )\n}\n","import React from 'react'\nimport {ConnectElementsProvider, useConnectElements} from './elements'\nimport {ConnectLines} from './lines'\n\ninterface ConnectProviderProps {\n  children: React.ReactNode\n}\n\nfunction ConnectProviderInner() {\n  const {elements} = useConnectElements()\n\n  return <ConnectLines elements={elements} />\n}\n\nexport function ConnectProvider(props: ConnectProviderProps) {\n  const {children} = props\n\n  return (\n    <ConnectElementsProvider>\n      {children}\n      <ConnectProviderInner />\n    </ConnectElementsProvider>\n  )\n}\n"],"names":["$c81829298c0be717$export$b18e34ac3520f2e5","$cPJmq$react","createContext","elements","dispatch","$61adfabb2f38684e$export$fc84c22acd302ca7","useContext","Error","$96743ad87b9e841b$export$e1957580bb403527","state","payload","type","id","element","connectWith","exists","some","l","node","next","map","el","x","filter","y","$4e6eeef5ea3a8411$export$5c92df8ce16beba9","props","children","useReducer","ctxVal","useMemo","$cPJmq$reactjsxruntime","jsx","Provider","value","$e800e1848c86903d$export$59e6910693f047c2","nodeRef","useRef","handleAdd","useCallback","current","clone","childProps","cloneElement","ref","useEffect","$7494e3fa284d64f1$export$def641b22e0a4283","paths","edge","p","index","join","$084cb7a41b2ad8c5$export$d16800b7e59a8051","document","querySelector","$7fbeb89c00c7d91a$var$EMPTY_ARRAY","$7fbeb89c00c7d91a$export$790ca4df398846a2","e","length","connectEls","c","a","includes","rect","getBoundingClientRect","color","find","stroke","from","to","Boolean","$23d18a97be95b3fa$export$7709b8005774fb51","fromRect","toRect","position","allowYConnect","left","right","width","bottomToTop","bottom","top","topToBottom","rightToLeft","leftToRight","$23d18a97be95b3fa$var$getPosition","height","$d961c3c0afed5118$var$SVG_STYLE","pointerEvents","$d961c3c0afed5118$var$EMPTY_ARRAY","$d961c3c0afed5118$export$775ba819c8141467","pointsData","setPointsData","useState","isInteracting","setIsInteracting","raf","colors","Set","flat","handleCalcLines","window","cancelAnimationFrame","requestAnimationFrame","data1","data","toArray","pathDataArr","pathData","path","test","fromId","toId","d","handleStartInteracting","handleStopInteracting","handleUpdateLines","addEventListener","passive","removeEventListener","ro","ResizeObserver","forEach","observe","disconnect","unobserve","jsxs","style","markerHeight","markerUnits","markerWidth","orient","refX","refY","viewBox","fill","markerEnd","strokeWidth","strokeDasharray","strokeLinejoin","$4f2fb7e80f557106$var$ConnectProviderInner","$4f2fb7e80f557106$export$230737e70939b618"],"version":3,"file":"index.js.map"}